#!/usr/bin/env node

/**
 * üéÆ INTERAKTIVN√ç TESTER - SIMULACE RE√ÅLN√ùCH HERN√çCH AKC√ç
 * 
 * Tento test simuluje re√°ln√© hern√≠ situace s DOM manipulac√≠:
 * - Klik√°n√≠ na tlaƒç√≠tka a jejich odezva
 * - Zmƒõny stavu tlaƒç√≠tek v re√°ln√©m ƒçase
 * - Animace a p≈ôechody mezi stavy
 * - Chybov√© stavy a jejich zpracov√°n√≠
 * - Kompletn√≠ hern√≠ session od zaƒç√°tku do konce
 * - AI chov√°n√≠ a reakce
 * - Responsivn√≠ layout na r≈Øzn√Ωch velikostech
 * 
 * C√çLE:
 * - 100% pokryt√≠ v≈°ech klikateln√Ωch element≈Ø
 * - Testov√°n√≠ v≈°ech mo≈æn√Ωch hern√≠ch stav≈Ø
 * - Validace UX flow a chybov√Ωch stav≈Ø
 * - Ovƒõ≈ôen√≠ Bootstrap responzivity
 */

import { calculatePoints, hasScoringDice } from '../../src/js/game/diceMechanics.js';
import gameState from '../../src/js/game/gameState.js';

// Simul√°tor DOM prost≈ôed√≠ s event handling
class InteractiveDOMSimulator {
    constructor() {
        this.elements = new Map();
        this.eventHandlers = new Map();
        this.clickHistory = [];
        this.stateHistory = [];
        this.animationQueue = [];
        this.setupDOM();
    }

    setupDOM() {
        // Hern√≠ oblast
        this.addElement('gameArea', 'div', {
            className: 'container-fluid h-100',
            id: 'gameArea'
        });

        // Hern√≠ tlaƒç√≠tka
        this.addElement('rollDiceBtn', 'button', {
            className: 'btn btn-neon',
            'data-neon-color': 'green',
            textContent: 'üé≤ HODIT',
            disabled: false
        });

        this.addElement('saveDiceBtn', 'button', {
            className: 'btn btn-neon',
            'data-neon-color': 'blue',
            textContent: 'üíæ ODLO≈ΩIT',
            disabled: true
        });

        this.addElement('endTurnBtn', 'button', {
            className: 'btn btn-neon',
            'data-neon-color': 'orange',
            textContent: '‚úÖ UKONƒåIT TAH',
            disabled: true
        });

        this.addElement('menuBtn', 'button', {
            className: 'btn btn-neon',
            'data-neon-color': 'red',
            textContent: 'üìã MENU',
            disabled: false
        });

        // Kostky (6 kus≈Ø)
        for (let i = 0; i < 6; i++) {
            this.addElement(`dice${i}`, 'div', {
                className: 'dice dice-clickable',
                'data-index': i,
                'data-value': 1,
                textContent: '‚öÄ'
            });
        }

        // Menu tlaƒç√≠tka
        this.addElement('startGameBtn', 'button', {
            className: 'btn btn-neon',
            'data-neon-color': 'green',
            textContent: 'üéÆ HR√ÅT',
            disabled: false
        });

        this.addElement('rulesBtn', 'button', {
            className: 'btn btn-neon',
            'data-neon-color': 'blue',
            textContent: 'üìú PRAVIDLA',
            disabled: false
        });

        this.addElement('hallOfFameBtn', 'button', {
            className: 'btn btn-neon',
            'data-neon-color': 'purple',
            textContent: 'üèÜ S√çNƒö SL√ÅVY',
            disabled: false
        });

        this.addElement('exitBtn', 'button', {
            className: 'btn btn-neon',
            'data-neon-color': 'red',
            textContent: '‚ùå KONEC',
            disabled: false
        });

        // Hern√≠ informace
        this.addElement('currentPlayerInfo', 'div', {
            className: 'text-center text-neon-green',
            textContent: 'Hr√°ƒç na tahu: Test'
        });

        this.addElement('turnScoreInfo', 'div', {
            className: 'text-center text-neon-blue',
            textContent: 'Body v tahu: 0'
        });

        this.addElement('targetScoreInfo', 'div', {
            className: 'text-center text-neon-yellow',
            textContent: 'C√≠l: 1000'
        });

        console.log('‚úÖ DOM simulator nastaven s', this.elements.size, 'elementy');
    }

    addElement(id, tagName, attributes = {}) {
        const element = {
            id,
            tagName: tagName.toUpperCase(),
            className: attributes.className || '',
            disabled: attributes.disabled || false,
            textContent: attributes.textContent || '',
            style: {},
            classList: {
                add: (className) => {
                    const classes = element.className.split(' ');
                    if (!classes.includes(className)) {
                        classes.push(className);
                        element.className = classes.join(' ');
                    }
                },
                remove: (className) => {
                    const classes = element.className.split(' ');
                    element.className = classes.filter(c => c !== className).join(' ');
                },
                contains: (className) => element.className.includes(className)
            },
            addEventListener: (event, handler) => {
                if (!this.eventHandlers.has(id)) {
                    this.eventHandlers.set(id, new Map());
                }
                if (!this.eventHandlers.get(id).has(event)) {
                    this.eventHandlers.get(id).set(event, []);
                }
                this.eventHandlers.get(id).get(event).push(handler);
            },
            click: () => this.simulateClick(id),
            ...attributes
        };

        this.elements.set(id, element);
        return element;
    }

    simulateClick(elementId) {
        const element = this.elements.get(elementId);
        if (!element) {
            console.warn(`‚ö†Ô∏è Element ${elementId} nenalezen pro click`);
            return false;
        }

        if (element.disabled) {
            console.warn(`‚ö†Ô∏è Element ${elementId} je zak√°z√°n`);
            return false;
        }

        // Zaznamen√°me click
        this.clickHistory.push({
            elementId,
            timestamp: Date.now(),
            elementState: { ...element }
        });

        // Spust√≠me event handlery
        const handlers = this.eventHandlers.get(elementId);
        if (handlers && handlers.has('click')) {
            handlers.get('click').forEach(handler => {
                try {
                    handler();
                } catch (error) {
                    console.error(`‚ùå Chyba v click handleru pro ${elementId}:`, error);
                }
            });
        }

        return true;
    }

    getElement(id) {
        return this.elements.get(id);
    }

    updateElementState(id, updates) {
        const element = this.elements.get(id);
        if (element) {
            Object.assign(element, updates);

            // Zaznamen√°me zmƒõnu stavu
            this.stateHistory.push({
                elementId: id,
                timestamp: Date.now(),
                updates,
                newState: { ...element }
            });
        }
    }

    isElementVisible(id) {
        const element = this.elements.get(id);
        return element && !element.style.display?.includes('none');
    }

    isElementEnabled(id) {
        const element = this.elements.get(id);
        return element && !element.disabled;
    }

    hasClass(id, className) {
        const element = this.elements.get(id);
        return element && element.classList.contains(className);
    }

    getClickHistory() {
        return [...this.clickHistory];
    }

    getStateHistory() {
        return [...this.stateHistory];
    }

    clearHistory() {
        this.clickHistory = [];
        this.stateHistory = [];
    }
}

// Interaktivn√≠ tester pro hern√≠ akce
class InteractiveGameTester {
    constructor() {
        this.dom = new InteractiveDOMSimulator();
        this.testResults = [];
        this.errors = [];
        this.scenarios = [];
        this.setupGameHandlers();
    }

    setupGameHandlers() {
        // Simulace hern√≠ch ud√°lost√≠
        this.dom.getElement('rollDiceBtn').addEventListener('click', () => {
            this.handleRollDice();
        });

        this.dom.getElement('saveDiceBtn').addEventListener('click', () => {
            this.handleSaveDice();
        });

        this.dom.getElement('endTurnBtn').addEventListener('click', () => {
            this.handleEndTurn();
        });

        this.dom.getElement('menuBtn').addEventListener('click', () => {
            this.handleShowMenu();
        });

        this.dom.getElement('startGameBtn').addEventListener('click', () => {
            this.handleStartGame();
        });

        // Kostky
        for (let i = 0; i < 6; i++) {
            this.dom.getElement(`dice${i}`).addEventListener('click', () => {
                this.handleDiceClick(i);
            });
        }

        console.log('‚úÖ Event handlery nastaveny');
    }

    handleRollDice() {
        console.log('üé≤ H√°zen√≠ kostkami...');

        // Simulace hodu
        const roll = Array.from({ length: 6 }, () => Math.floor(Math.random() * 6) + 1);
        gameState.updateState({
            currentRoll: roll,
            selectedDice: [],
            isRolling: true
        });

        // Aktualizace kostek v DOM
        roll.forEach((value, index) => {
            const diceSymbols = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
            this.dom.updateElementState(`dice${index}`, {
                'data-value': value,
                textContent: diceSymbols[value - 1]
            });
        });

        // Aktualizace tlaƒç√≠tek
        this.updateButtonStates();

        setTimeout(() => {
            gameState.updateState({ isRolling: false });
            this.updateButtonStates();
        }, 1000);
    }

    handleSaveDice() {
        console.log('üíæ Ukl√°d√°n√≠ kostek...');

        const state = gameState.getState();
        const selectedIndices = state.selectedDice || [];
        const selectedValues = selectedIndices.map(i => state.currentRoll[i]);
        const points = calculatePoints(selectedValues);

        if (points > 0) {
            gameState.updateState({
                turnScore: (state.turnScore || 0) + points,
                savedDice: [...(state.savedDice || []), ...selectedValues],
                selectedDice: [],
                // Odebr√°n√≠ ulo≈æen√Ωch kostek z aktu√°ln√≠ho hodu
                currentRoll: state.currentRoll.filter((_, index) => !selectedIndices.includes(index))
            });

            this.updateScoreDisplay();
            this.updateButtonStates();
        }
    }

    handleEndTurn() {
        console.log('‚úÖ Ukonƒçen√≠ tahu...');

        const state = gameState.getState();
        const currentPlayer = state.players[state.currentPlayerIndex];
        const turnScore = state.turnScore || 0;

        // Validace prvn√≠ho z√°pisu
        if (currentPlayer.score === 0 && turnScore < 300) {
            console.warn('‚ùå Prvn√≠ z√°pis mus√≠ b√Ωt alespo≈à 300 bod≈Ø!');
            return;
        }

        // P≈ôiƒçten√≠ bod≈Ø a p≈ôechod na dal≈°√≠ho hr√°ƒçe
        const updatedPlayers = [...state.players];
        updatedPlayers[state.currentPlayerIndex].score += turnScore;

        gameState.updateState({
            players: updatedPlayers,
            currentPlayerIndex: (state.currentPlayerIndex + 1) % state.players.length,
            turnScore: 0,
            savedDice: [],
            currentRoll: [],
            selectedDice: []
        });

        this.updateScoreDisplay();
        this.updateButtonStates();
    }

    handleShowMenu() {
        console.log('üìã Zobrazen√≠ menu...');
        gameState.updateState({ gamePhase: 'menu' });
        this.updateButtonStates();
    }

    handleStartGame() {
        console.log('üéÆ Spu≈°tƒõn√≠ hry...');
        gameState.reset();
        gameState.updateState({
            gamePhase: 'game',
            players: [
                { name: 'Hr√°ƒç', score: 0, isHuman: true },
                { name: 'AI1', score: 0, isHuman: false },
                { name: 'AI2', score: 0, isHuman: false }
            ]
        });
        this.updateButtonStates();
        this.updateScoreDisplay();
    }

    handleDiceClick(index) {
        console.log(`üéØ Klik na kostku ${index}...`);

        const state = gameState.getState();
        const selectedDice = [...(state.selectedDice || [])];

        if (selectedDice.includes(index)) {
            // Odznaƒçen√≠ kostky
            const newSelected = selectedDice.filter(i => i !== index);
            gameState.updateState({ selectedDice: newSelected });
            this.dom.getElement(`dice${index}`).classList.remove('dice-selected');
        } else {
            // Oznaƒçen√≠ kostky
            selectedDice.push(index);
            gameState.updateState({ selectedDice: selectedDice });
            this.dom.getElement(`dice${index}`).classList.add('dice-selected');
        }

        this.updateButtonStates();
    }

    updateButtonStates() {
        const state = gameState.getState();

        switch (state.gamePhase) {
            case 'menu':
                this.dom.updateElementState('startGameBtn', { disabled: false });
                this.dom.updateElementState('rulesBtn', { disabled: false });
                this.dom.updateElementState('hallOfFameBtn', { disabled: false });
                this.dom.updateElementState('exitBtn', { disabled: false });
                break;

            case 'game':
                const hasCurrentRoll = state.currentRoll && state.currentRoll.length > 0;
                const hasSelectedDice = state.selectedDice && state.selectedDice.length > 0;
                const hasTurnScore = (state.turnScore || 0) > 0;
                const currentPlayer = state.players[state.currentPlayerIndex];
                const canEndTurn = currentPlayer.score > 0 || (state.turnScore || 0) >= 300;

                this.dom.updateElementState('rollDiceBtn', {
                    disabled: state.isRolling || (hasCurrentRoll && !hasSelectedDice)
                });

                this.dom.updateElementState('saveDiceBtn', {
                    disabled: !hasSelectedDice || state.isRolling
                });

                this.dom.updateElementState('endTurnBtn', {
                    disabled: !hasTurnScore || !canEndTurn || state.isRolling
                });

                this.dom.updateElementState('menuBtn', { disabled: false });
                break;
        }
    }

    updateScoreDisplay() {
        const state = gameState.getState();
        const currentPlayer = state.players[state.currentPlayerIndex];

        this.dom.updateElementState('currentPlayerInfo', {
            textContent: `Hr√°ƒç na tahu: ${currentPlayer.name} (${currentPlayer.score})`
        });

        this.dom.updateElementState('turnScoreInfo', {
            textContent: `Body v tahu: ${state.turnScore || 0}`
        });

        this.dom.updateElementState('targetScoreInfo', {
            textContent: `C√≠l: ${state.targetScore || 1000}`
        });
    }

    log(message, type = 'info') {
        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
        const colors = {
            info: '\x1b[36m',    // cyan
            success: '\x1b[32m', // green
            error: '\x1b[31m',   // red
            warning: '\x1b[33m', // yellow
            test: '\x1b[35m',    // magenta
            interaction: '\x1b[96m', // bright cyan
            reset: '\x1b[0m'
        };

        console.log(`${colors[type]}[${timestamp}] ${message}${colors.reset}`);
    }

    runTest(name, testFunction) {
        this.log(`üß™ Test: ${name}`, 'test');

        try {
            const result = testFunction();
            if (result.success) {
                this.log(`‚úÖ ${name} - PRO≈†EL`, 'success');
                this.testResults.push({ name, status: 'PASS', ...result });
            } else {
                this.log(`‚ùå ${name} - SELHAL: ${result.reason}`, 'error');
                this.testResults.push({ name, status: 'FAIL', ...result });
                this.errors.push({ name, ...result });
            }
        } catch (error) {
            this.log(`üí• ${name} - V√ùJIMKA: ${error.message}`, 'error');
            this.testResults.push({ name, status: 'ERROR', error: error.message });
            this.errors.push({ name, error: error.message });
        }
    }

    // Test 1: Z√°kladn√≠ interakce s tlaƒç√≠tky
    testBasicButtonInteractions() {
        return this.runTest('Z√°kladn√≠ interakce s tlaƒç√≠tky', () => {
            this.dom.clearHistory();

            // Test menu tlaƒç√≠tek
            const menuButtons = ['startGameBtn', 'rulesBtn', 'hallOfFameBtn', 'exitBtn'];
            const menuClickResults = [];

            gameState.updateState({ gamePhase: 'menu' });

            for (const buttonId of menuButtons) {
                const success = this.dom.simulateClick(buttonId);
                menuClickResults.push({ buttonId, success });
            }

            const failedMenuClicks = menuClickResults.filter(r => !r.success);
            if (failedMenuClicks.length > 0) {
                return {
                    success: false,
                    reason: `Ne√∫spƒõ≈°n√© kliky na menu tlaƒç√≠tka: ${failedMenuClicks.map(r => r.buttonId).join(', ')}`,
                    failedClicks: failedMenuClicks
                };
            }

            // Test hern√≠ch tlaƒç√≠tek
            gameState.updateState({ gamePhase: 'game' });
            this.updateButtonStates();

            const gameButtons = ['rollDiceBtn', 'menuBtn'];
            const gameClickResults = [];

            for (const buttonId of gameButtons) {
                const success = this.dom.simulateClick(buttonId);
                gameClickResults.push({ buttonId, success });
            }

            const failedGameClicks = gameClickResults.filter(r => !r.success);
            if (failedGameClicks.length > 0) {
                return {
                    success: false,
                    reason: `Ne√∫spƒõ≈°n√© kliky na hern√≠ tlaƒç√≠tka: ${failedGameClicks.map(r => r.buttonId).join(', ')}`,
                    failedClicks: failedGameClicks
                };
            }

            const totalClicks = this.dom.getClickHistory().length;
            return {
                success: true,
                totalClicks,
                menuClicks: menuClickResults.length,
                gameClicks: gameClickResults.length
            };
        });
    }

    // Test 2: V√Ωbƒõr kostek a jejich validace
    testDiceSelectionInteractions() {
        return this.runTest('V√Ωbƒõr kostek - interakce', () => {
            this.dom.clearHistory();

            // Nastav√≠me hern√≠ stav s kostkami
            gameState.updateState({
                gamePhase: 'game',
                currentRoll: [1, 1, 1, 2, 3, 4],
                selectedDice: []
            });

            // Aktualizujeme kostky v DOM
            const roll = [1, 1, 1, 2, 3, 4];
            const diceSymbols = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];

            roll.forEach((value, index) => {
                this.dom.updateElementState(`dice${index}`, {
                    'data-value': value,
                    textContent: diceSymbols[value - 1]
                });
            });

            // Test v√Ωbƒõru validn√≠ch kostek (3 jedniƒçky)
            const validSelections = [0, 1, 2]; // T≈ôi jedniƒçky
            const selectionResults = [];

            for (const diceIndex of validSelections) {
                const success = this.dom.simulateClick(`dice${diceIndex}`);
                selectionResults.push({ diceIndex, success });

                // Zkontrolujeme, ≈æe kostka je oznaƒçena
                const isSelected = this.dom.hasClass(`dice${diceIndex}`, 'dice-selected');
                if (!isSelected) {
                    return {
                        success: false,
                        reason: `Kostka ${diceIndex} nebyla oznaƒçena po kliknut√≠`,
                        diceIndex
                    };
                }
            }

            // Test nevalidn√≠ch kostek (2, 3, 4 jednotlivƒõ)
            const invalidSelections = [3, 4, 5]; // Jednotliv√© 2, 3, 4

            for (const diceIndex of invalidSelections) {
                const success = this.dom.simulateClick(`dice${diceIndex}`);

                // Nevalidn√≠ kostky by se nemƒõly oznaƒçit
                const isSelected = this.dom.hasClass(`dice${diceIndex}`, 'dice-selected');
                if (isSelected) {
                    return {
                        success: false,
                        reason: `Kostka ${diceIndex} byla chybnƒõ oznaƒçena (nevalidn√≠)`,
                        diceIndex
                    };
                }
            }

            // Test odznaƒçen√≠ kostek
            for (const diceIndex of validSelections) {
                const success = this.dom.simulateClick(`dice${diceIndex}`);

                // Kostka by se mƒõla odznaƒçit
                const isSelected = this.dom.hasClass(`dice${diceIndex}`, 'dice-selected');
                if (isSelected) {
                    return {
                        success: false,
                        reason: `Kostka ${diceIndex} se neodznaƒçila`,
                        diceIndex
                    };
                }
            }

            return {
                success: true,
                validSelections: validSelections.length,
                invalidSelections: invalidSelections.length,
                totalDiceClicks: this.dom.getClickHistory().length
            };
        });
    }

    // Test 3: Kompletn√≠ hern√≠ session
    testCompleteGameSession() {
        return this.runTest('Kompletn√≠ hern√≠ session', () => {
            this.dom.clearHistory();

            // Zaƒçneme v menu
            gameState.updateState({ gamePhase: 'menu' });
            this.updateButtonStates();

            // Spust√≠me hru
            this.dom.simulateClick('startGameBtn');

            const state1 = gameState.getState();
            if (state1.gamePhase !== 'game') {
                return {
                    success: false,
                    reason: 'Nepoda≈ôilo se spustit hru z menu',
                    currentPhase: state1.gamePhase
                };
            }

            // Simulujeme nƒõkolik tah≈Ø
            const turnResults = [];

            for (let turn = 0; turn < 3; turn++) {
                // Hod√≠me kostkami
                this.dom.simulateClick('rollDiceBtn');

                // Poƒçk√°me na dokonƒçen√≠ animace
                setTimeout(() => {
                    const state = gameState.getState();

                    // Najdeme validn√≠ kostky
                    const validDice = [];
                    state.currentRoll.forEach((value, index) => {
                        if (value === 1 || value === 5) {
                            validDice.push(index);
                        }
                    });

                    // Oznaƒç√≠me validn√≠ kostky
                    validDice.forEach(index => {
                        this.dom.simulateClick(`dice${index}`);
                    });

                    // Ulo≈æ√≠me kostky
                    if (validDice.length > 0) {
                        this.dom.simulateClick('saveDiceBtn');
                    }

                    // Pokud m√°me dostatek bod≈Ø, ukonƒç√≠me tah
                    const currentState = gameState.getState();
                    if ((currentState.turnScore || 0) >= 300) {
                        this.dom.simulateClick('endTurnBtn');
                    }

                    turnResults.push({
                        turn,
                        roll: state.currentRoll,
                        validDice,
                        turnScore: currentState.turnScore
                    });
                }, 100);
            }

            // Zkontrolujeme v√Ωsledky
            const totalClicks = this.dom.getClickHistory().length;
            const stateChanges = this.dom.getStateHistory().length;

            return {
                success: true,
                totalClicks,
                stateChanges,
                turnResults: turnResults.length
            };
        });
    }

    // Test 4: Chybov√© stavy a jejich zpracov√°n√≠
    testErrorStatesAndHandling() {
        return this.runTest('Chybov√© stavy - zpracov√°n√≠', () => {
            this.dom.clearHistory();

            // Test 1: Klik na zak√°zan√© tlaƒç√≠tko
            gameState.updateState({ gamePhase: 'game' });
            this.updateButtonStates();

            // saveDiceBtn by mƒõl b√Ωt zak√°z√°n bez v√Ωbƒõru kostek
            const saveDiceElement = this.dom.getElement('saveDiceBtn');
            saveDiceElement.disabled = true;

            const disabledClickSuccess = this.dom.simulateClick('saveDiceBtn');
            if (disabledClickSuccess) {
                return {
                    success: false,
                    reason: 'Klik na zak√°zan√© tlaƒç√≠tko byl √∫spƒõ≈°n√Ω (nemƒõl by b√Ωt)',
                    buttonId: 'saveDiceBtn'
                };
            }

            // Test 2: Prvn√≠ z√°pis s nedostateƒçn√Ωmi body
            gameState.updateState({
                players: [{ name: 'Test', score: 0, isHuman: true }],
                currentPlayerIndex: 0,
                turnScore: 150 // M√©nƒõ ne≈æ 300
            });

            this.updateButtonStates();

            const endTurnElement = this.dom.getElement('endTurnBtn');
            const shouldBeDisabled = endTurnElement.disabled;

            if (!shouldBeDisabled) {
                return {
                    success: false,
                    reason: 'Tlaƒç√≠tko "Ukonƒçit tah" by mƒõlo b√Ωt zak√°z√°no p≈ôi prvn√≠m z√°pisu < 300 bod≈Ø',
                    turnScore: 150
                };
            }

            // Test 3: Neexistuj√≠c√≠ element
            const invalidClickSuccess = this.dom.simulateClick('nonExistentButton');
            if (invalidClickSuccess) {
                return {
                    success: false,
                    reason: 'Klik na neexistuj√≠c√≠ element byl √∫spƒõ≈°n√Ω (nemƒõl by b√Ωt)',
                    buttonId: 'nonExistentButton'
                };
            }

            return {
                success: true,
                disabledClicksPrevented: 2,
                invalidClicksPrevented: 1
            };
        });
    }

    // Test 5: Responsivn√≠ layout a Bootstrap komponenty
    testResponsiveLayoutAndBootstrap() {
        return this.runTest('Responsivn√≠ layout a Bootstrap', () => {
            const bootstrapTests = [];

            // Test Bootstrap t≈ô√≠d na elementech
            const elementsWithBootstrap = [
                { id: 'gameArea', expectedClasses: ['container-fluid', 'h-100'] },
                { id: 'rollDiceBtn', expectedClasses: ['btn', 'btn-neon'] },
                { id: 'saveDiceBtn', expectedClasses: ['btn', 'btn-neon'] },
                { id: 'endTurnBtn', expectedClasses: ['btn', 'btn-neon'] },
                { id: 'currentPlayerInfo', expectedClasses: ['text-center', 'text-neon-green'] },
                { id: 'turnScoreInfo', expectedClasses: ['text-center', 'text-neon-blue'] }
            ];

            for (const test of elementsWithBootstrap) {
                const element = this.dom.getElement(test.id);
                if (!element) {
                    bootstrapTests.push({
                        elementId: test.id,
                        success: false,
                        reason: 'Element nenalezen'
                    });
                    continue;
                }

                const missingClasses = test.expectedClasses.filter(cls =>
                    !element.className.includes(cls)
                );

                if (missingClasses.length > 0) {
                    bootstrapTests.push({
                        elementId: test.id,
                        success: false,
                        reason: `Chyb√≠ Bootstrap t≈ô√≠dy: ${missingClasses.join(', ')}`,
                        missingClasses
                    });
                } else {
                    bootstrapTests.push({
                        elementId: test.id,
                        success: true,
                        foundClasses: test.expectedClasses
                    });
                }
            }

            // Test neon barev
            const neonColorTests = [
                { id: 'rollDiceBtn', expectedNeonColor: 'green' },
                { id: 'saveDiceBtn', expectedNeonColor: 'blue' },
                { id: 'endTurnBtn', expectedNeonColor: 'orange' },
                { id: 'menuBtn', expectedNeonColor: 'red' }
            ];

            for (const test of neonColorTests) {
                const element = this.dom.getElement(test.id);
                if (!element) continue;

                const hasNeonColor = element['data-neon-color'] === test.expectedNeonColor;
                bootstrapTests.push({
                    elementId: test.id,
                    success: hasNeonColor,
                    reason: hasNeonColor ? 'Spr√°vn√° neon barva' :
                        `Oƒçek√°van√° barva: ${test.expectedNeonColor}, nalezeno: ${element['data-neon-color']}`
                });
            }

            const failedBootstrapTests = bootstrapTests.filter(test => !test.success);

            if (failedBootstrapTests.length > 0) {
                return {
                    success: false,
                    reason: `Bootstrap testy selhaly: ${failedBootstrapTests.length} probl√©m≈Ø`,
                    failedTests: failedBootstrapTests,
                    allTests: bootstrapTests
                };
            }

            return {
                success: true,
                bootstrapTestsCount: bootstrapTests.length,
                elementsWithBootstrap: elementsWithBootstrap.length,
                neonColorTests: neonColorTests.length
            };
        });
    }

    // Hlavn√≠ spou≈°tƒõc√≠ metoda
    runAllInteractiveTests() {
        this.log('\nüéÆ SPOU≈†TƒöN√ç INTERAKTIVN√çCH UI TEST≈Æ', 'interaction');
        this.log('='.repeat(80), 'interaction');

        // Spu≈°tƒõn√≠ v≈°ech test≈Ø
        this.testBasicButtonInteractions();
        this.testDiceSelectionInteractions();
        this.testCompleteGameSession();
        this.testErrorStatesAndHandling();
        this.testResponsiveLayoutAndBootstrap();

        // Zobrazen√≠ v√Ωsledk≈Ø
        this.displayResults();
    }

    displayResults() {
        const total = this.testResults.length;
        const passed = this.testResults.filter(r => r.status === 'PASS').length;
        const failed = this.testResults.filter(r => r.status === 'FAIL').length;
        const errors = this.testResults.filter(r => r.status === 'ERROR').length;

        this.log('\nüéØ SOUHRN INTERAKTIVN√çCH TEST≈Æ', 'interaction');
        this.log('='.repeat(80), 'interaction');
        this.log(`üìä Celkem test≈Ø: ${total}`, 'info');
        this.log(`‚úÖ √öspƒõ≈°n√©: ${passed}`, 'success');
        this.log(`‚ùå Ne√∫spƒõ≈°n√©: ${failed}`, 'error');
        this.log(`üí• Chyby: ${errors}`, 'error');
        this.log(`üìà √öspƒõ≈°nost: ${((passed / total) * 100).toFixed(1)}%`,
            passed === total ? 'success' : 'warning');

        // Interaktivn√≠ statistiky
        this.log('\nüéÆ INTERAKTIVN√ç STATISTIKY', 'interaction');
        this.log('-'.repeat(50), 'interaction');
        this.log(`üñ±Ô∏è  Celkov√© kliky: ${this.dom.getClickHistory().length}`, 'info');
        this.log(`üîÑ Zmƒõny stavu: ${this.dom.getStateHistory().length}`, 'info');
        this.log(`üéØ Testovan√© elementy: ${this.dom.elements.size}`, 'info');
        this.log(`üì± Bootstrap komponenty: ${this.testResults.filter(r => r.name.includes('Bootstrap')).length}`, 'info');

        if (this.errors.length > 0) {
            this.log('\nüîç DETAILY CHYB', 'warning');
            this.log('-'.repeat(50), 'warning');

            this.errors.forEach(error => {
                this.log(`‚ùå ${error.name}: ${error.reason || error.error}`, 'error');
            });
        }

        this.log('\nüí° DOPORUƒåEN√ç', 'warning');
        this.log('-'.repeat(50), 'warning');

        if (failed > 0 || errors > 0) {
            this.log('üîß Zkontroluj event handling a DOM manipulaci', 'warning');
            this.log('üîß Ovƒõ≈ô Bootstrap t≈ô√≠dy a responzivitu', 'warning');
            this.log('üîß Provƒõ≈ô chybov√© stavy a validace', 'warning');
        } else {
            this.log('üéâ V≈°echny interaktivn√≠ testy pro≈°ly!', 'success');
            this.log('üéÆ UI je plnƒõ funkƒçn√≠ a p≈ôipraven√© pro hru!', 'success');
        }

        this.log('\nüèÅ HOTOVO', 'interaction');
        this.log('='.repeat(80), 'interaction');
    }
}

// Spu≈°tƒõn√≠ interaktivn√≠ch test≈Ø
const interactiveTester = new InteractiveGameTester();
interactiveTester.runAllInteractiveTests();
