/**
 * Dice Mechanics - Mechaniky pro pr√°ci s kostkami
 * Modul obsahuje ve≈°kerou logiku pro h√°zen√≠ kostkami a vyhodnocov√°n√≠ v√Ωsledk≈Ø
 */

/**
 * SEZNAM POU≈Ω√çVAN√ùCH CSS T≈ò√çD:
 * Bootstrap: (≈æ√°dn√© p≈ô√≠m√© CSS t≈ô√≠dy - ƒçist√© game logic)
 * Neon t≈ô√≠dy: (≈æ√°dn√© - logika bez UI)
 * Vlastn√≠: (≈æ√°dn√© - ƒçist√° logika)
 */

/**
 * SEZNAM PROMƒöNN√ùCH (lok√°ln√≠ v metod√°ch):
 * result, i, points, counts, count, value, die
 * 
 * MO≈ΩN√â DUPLICITY: 
 * - counts (pou≈æ√≠v√° se v calculatePoints, hasScoringDice, isValidFarkleCombination - OK, r≈Øzn√© scope)
 * - count (pou≈æ√≠v√° se v calculatePoints a isValidFarkleCombination - OK, r≈Øzn√© scope)
 * - value (pou≈æ√≠v√° se ve v≈°ech for cyklech - OK, lok√°ln√≠ scope)
 */

// Konstanty pro kostky
import { DICE_CONSTANTS } from '../utils/constants.js';

/**
 * Vygeneruje n√°hodn√Ω hod kostkou (1-6)
 * @returns {number} Hodnota kostky 1-6
 */
export const rollDie = () => {
    return Math.floor(Math.random() * DICE_CONSTANTS.MAX_VALUE) + DICE_CONSTANTS.MIN_VALUE;
};

/**
 * Vygeneruje hod v√≠ce kostkami najednou
 * @param {number} count - Poƒçet kostek
 * @returns {Array<number>} Pole s hodnotami kostek
 */
export const rollDice = (count) => {
    const result = [];
    for (let i = 0; i < count; i++) {
        result.push(rollDie());
    }
    return result;
};

/**
 * Spoƒç√≠t√° body z dan√©ho hodu kostek
 * @param {Array<number>} dice - Pole s hodnotami kostek
 * @returns {number} Poƒçet bod≈Ø
 */
export const calculatePoints = (dice) => {
    if (!dice || !dice.length) return 0;
    
    let points = 0;
    const counts = countDiceValues(dice);
    
    // NEJPRVE KONTROLA T≈ò√ç P√ÅR≈Æ (nejvy≈°≈°√≠ priorita)
    // T≈ôi p√°ry = 1500 bod≈Ø (nap≈ô. 2,2,6,6,3,3)
    let pairCount = 0;
    const originalCounts = { ...counts }; // Kopie pro kontrolu p√°r≈Ø
    
    for (let value = DICE_CONSTANTS.MIN_VALUE; value <= DICE_CONSTANTS.MAX_VALUE; value++) {
        if (originalCounts[value] === 2) {
            pairCount++;
        }
    }
    
    if (pairCount === 3) {
        console.log(`üéØ Detekov√°ny T≈òI P√ÅRY = 1500 bod≈Ø`);
        return 1500; // T≈ôi p√°ry = 1500 bod≈Ø (≈æ√°dn√© jin√© kombinace se nepoƒç√≠taj√≠)
    }
    
    // T≈ôi a v√≠ce stejn√Ωch kostek - podle poƒçtu kostek
    for (let value = DICE_CONSTANTS.MIN_VALUE; value <= DICE_CONSTANTS.MAX_VALUE; value++) {
        const count = counts[value];
        if (count >= 3) {
            // Speci√°ln√≠ bodov√°n√≠ pro jednotky
            if (value === DICE_CONSTANTS.MIN_VALUE) {
                // Trojice jedniƒçek = 1000, ƒçtve≈ôice = 2000, pƒõtice = 4000, ≈°estica = 8000
                switch (count) {
                    case 3: points += 1000; break;
                    case 4: points += 2000; break;
                    case 5: points += 4000; break;
                    case 6: points += 8000; break;
                }
            } else {
                // Ostatn√≠ ƒç√≠sla: trojice = hodnota √ó 100, pak se zdvojn√°sobuje
                switch (count) {
                    case 3: points += value * 100; break;    // 3√ó2 = 200
                    case 4: points += value * 200; break;    // 4√ó2 = 400  
                    case 5: points += value * 400; break;    // 5√ó2 = 800
                    case 6: points += value * 800; break;    // 6√ó2 = 1600
                }
            }
            
            // Odeƒçteme ji≈æ zapoƒç√≠tan√© kostky
            counts[value] = 0;
        }
    }
    
    // Jednotliv√© jedniƒçky a pƒõtky
    points += counts[DICE_CONSTANTS.MIN_VALUE] * DICE_CONSTANTS.SINGLE_ONE_POINTS; // Ka≈æd√° jednotka 100 bod≈Ø
    points += counts[5] * DICE_CONSTANTS.SINGLE_FIVE_POINTS;  // Ka≈æd√° pƒõtka 50 bod≈Ø
    
    return points;
};

/**
 * Spoƒç√≠t√° v√Ωskyt hodnot kostek
 * @param {Array<number>} dice - Pole s hodnotami kostek
 * @returns {Object} Objekt s poƒçty jednotliv√Ωch hodnot
 */
export const countDiceValues = (dice) => {
    const counts = {};
    
    // Inicializace poƒç√≠tadel pro v≈°echny mo≈æn√© hodnoty kostek
    for (let i = DICE_CONSTANTS.MIN_VALUE; i <= DICE_CONSTANTS.MAX_VALUE; i++) {
        counts[i] = 0;
    }
    
    // Poƒç√≠t√°n√≠ v√Ωskyt≈Ø hodnot
    for (const die of dice) {
        counts[die]++;
    }
    
    return counts;
};

/**
 * Zkontroluje, zda dan√Ω hod kostek obsahuje bodovan√© kombinace
 * @param {Array<number>} dice - Pole s hodnotami kostek
 * @returns {boolean} True pokud hod obsahuje bodovanou kombinaci
 */
export const hasScoringDice = (dice) => {
    console.log(`üé≤ hasScoringDice() vol√°na s kostkami:`, dice);
    
    if (!dice || !dice.length) {
        console.log(`‚ùå ≈Ω√°dn√© kostky nebo pr√°zdn√Ω array`);
        return false;
    }
    
    const counts = countDiceValues(dice);
    console.log(`üî¢ Poƒçty hodnot:`, counts);
    
    // KONTROLA T≈ò√ç P√ÅR≈Æ (nejvy≈°≈°√≠ priorita)
    let pairCount = 0;
    for (let value = DICE_CONSTANTS.MIN_VALUE; value <= DICE_CONSTANTS.MAX_VALUE; value++) {
        if (counts[value] === 2) {
            pairCount++;
        }
    }
    
    if (pairCount === 3) {
        console.log(`‚úÖ Nalezeny T≈òI P√ÅRY = 1500 bod≈Ø`);
        return true;
    }
    
    // Kontrola na t≈ôi a v√≠ce stejn√Ωch kostek
    for (let value = DICE_CONSTANTS.MIN_VALUE; value <= DICE_CONSTANTS.MAX_VALUE; value++) {
        if (counts[value] >= 3) {
            console.log(`‚úÖ Nalezeny 3+ kostky hodnoty ${value}: ${counts[value]}x`);
            return true;
        }
    }
    
    // Kontrola na jedniƒçky a pƒõtky
    if (counts[DICE_CONSTANTS.MIN_VALUE] > 0) {
        console.log(`‚úÖ Nalezeny jedniƒçky: ${counts[DICE_CONSTANTS.MIN_VALUE]}x`);
        return true;
    }
    
    if (counts[5] > 0) {
        console.log(`‚úÖ Nalezeny pƒõtky: ${counts[5]}x`);
        return true;
    }
    
    console.log(`‚ùå ≈Ω√°dn√© boduj√≠c√≠ kostky nenalezeny`);
    return false;
};

/**
 * Zkontroluje, zda vybran√© kostky tvo≈ô√≠ platnou Farkle kombinaci
 * @param {Array<number>} selectedDice - Vybran√© kostky k validaci
 * @returns {boolean} True pokud kombinace je validn√≠ podle Farkle pravidel
 */
export const isValidFarkleCombination = (selectedDice) => {
    if (!selectedDice || selectedDice.length === 0) return false;
    
    const counts = countDiceValues(selectedDice);
    
    // KONTROLA T≈ò√ç P√ÅR≈Æ
    let pairCount = 0;
    for (let value = DICE_CONSTANTS.MIN_VALUE; value <= DICE_CONSTANTS.MAX_VALUE; value++) {
        if (counts[value] === 2) {
            pairCount++;
        }
    }
    
    if (pairCount === 3 && selectedDice.length === 6) {
        return true; // T≈ôi p√°ry jsou v≈ædy validn√≠
    }
    
    // Projdeme v≈°echny hodnoty kostek
    for (let value = DICE_CONSTANTS.MIN_VALUE; value <= DICE_CONSTANTS.MAX_VALUE; value++) {
        const count = counts[value];
        if (count === 0) continue; // ≈Ω√°dn√© kostky t√©to hodnoty
        
        if (value === DICE_CONSTANTS.MIN_VALUE || value === 5) {
            // Jedniƒçky a pƒõtky: m≈Ø≈æeme m√≠t libovoln√Ω poƒçet (1+, nebo 3+ pro trojice)
            // V≈°e je validn√≠ - jednotliv√© i trojice
            continue;
        } else {
            // Pro 2,3,4,6: MUS√çME m√≠t alespo≈à 3 stejn√© (trojice ƒçi v√≠ce)
            if (count < 3) {
                return false; // Nevalidn√≠ - m√°me 2,3,4,6 ale m√©nƒõ ne≈æ 3 kusy
            }
        }
    }
    
    return true;
};
